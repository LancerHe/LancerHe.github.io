---
title: 几个正则表达式的学习心得
author: 谇雨
layout: post
permalink: /study_notes_of_regular.html
views:
  - 87
categories:
  - PHP
tags:
  - 学习心得
  - 正则
  - 表达式
---
一开始我的确正则表达式头疼。不过去网上看了一些文章，其实正则并不是很难，因此记录下学习心得。

1、符号 ^ 和 $ 分别用来匹配字符串的开始和结束：

<table style="border:1px solid #CCC;" width="600" border="0" cellspacing="" cellpadding="4">
  <tr>
    <td width="120">
      &#8220;^page&#8221;
    </td>
    
    <td width="240">
      开头一定要有 page 字符串
    </td>
    
    <td width="240">
      page=2； page=3&action=list；&#8230;
    </td>
  </tr>
  
  <tr>
    <td width="120">
      &#8220;=add$&#8221;
    </td>
    
    <td width="240">
      结尾一定要有 =add 的字符串
    </td>
    
    <td width="240">
      action=add； age=18&do=add；&#8230;
    </td>
  </tr>
  
  <tr>
    <td width="120">
      &#8220;^index$
    </td>
    
    <td width="240">
      以abc开头和以abc结尾的字符串
    </td>
    
    <td width="240">
      index(实际上只有这个结果)
    </td>
  </tr>
  
  <tr>
    <td width="120">
      &#8220;read&#8221;
    </td>
    
    <td width="240">
      匹配包含read的字符
    </td>
    
    <td width="240">
      action=read&export；&#8230;
    </td>
  </tr>
</table>

2、大括号{n,m},其中n<m，当m存在时候：

{n,m},匹配前面字符出现的次数为n-m次

当m不存在时：

{n,}匹配前面字符出现次数大于等于n次

{n}匹配前面字符出现等于n次

<table style="border:1px solid #CCC;" width="600" border="0" cellspacing="" cellpadding="4">
  <tr>
    <td width="120">
      &#8220;you{2}&#8221;
    </td>
    
    <td width="240">
      o后面一定要跟2个u（一个也不能少）
    </td>
    
    <td width="240">
      youu
    </td>
  </tr>
  
  <tr>
    <td width="120">
      &#8220;you{2,}&#8221;
    </td>
    
    <td width="240">
      o后面至少要跟2个u
    </td>
    
    <td width="240">
      youu；youuu；&#8230;
    </td>
  </tr>
  
  <tr>
    <td width="120">
      &#8220;you{2，4}&#8221;
    </td>
    
    <td width="240">
      o后面至少要跟2-4个u
    </td>
    
    <td width="240">
      youu；youuu；youuuu；
    </td>
  </tr>
</table>

3、符号 * 匹配前面字符出现0次或者多次；相当于{0,}

符号 + 匹配前面字符出现1次或者多次；{1,}

符号 ? 匹配前面字符出现0次或者1次；{0,1}

要点：&#8217;*&#8217; &#8216;+&#8217; 和 &#8216;?&#8217; 只管它前面那个字符。

<table style="border:1px solid #CCC;" width="600" border="0" cellspacing="" cellpadding="4">
  <tr>
    <td width="120">
      &#8220;you*&#8221;
    </td>
    
    <td width="240">
      o后面一定要跟0个或者多个u
    </td>
    
    <td width="240">
      yo；you；youu；&#8230;
    </td>
  </tr>
  
  <tr>
    <td width="120">
      &#8220;you+&#8221;
    </td>
    
    <td width="240">
      o后面至少要跟1个或者多个u
    </td>
    
    <td width="240">
      you；youu；youuu；&#8230;
    </td>
  </tr>
  
  <tr>
    <td width="120">
      &#8220;you?&#8221;
    </td>
    
    <td width="240">
      o后面至少要跟0个或者1个u
    </td>
    
    <td width="240">
      yo；you
    </td>
  </tr>
  
  <tr>
    <td width="120">
      &#8220;yo+u?&#8221;
    </td>
    
    <td width="240">
      至少1个以上o后跟着0个或者1个u
    </td>
    
    <td width="240">
      you；yoou；yo；yooo；&#8230;
    </td>
  </tr>
</table>

<!--more-->

  
4、&#8217;|&#8217;相当于OR操作，小括号'()&#8217;表示集合：

<table style="border:1px solid #CCC;" width="600" border="0" cellspacing="" cellpadding="4">
  <tr>
    <td width="120">
      &#8220;hi|hello&#8221;
    </td>
    
    <td>
      匹配含有&#8221;hi&#8221; 或者 &#8220;hello&#8221; 的 字符串；
    </td>
  </tr>
  
  <tr>
    <td width="120">
      &#8220;(hi|h)me&#8221;
    </td>
    
    <td>
      匹配含有&#8221;hime&#8221; 或者 &#8220;hme&#8221; 的 字符串；
    </td>
  </tr>
  
  <tr>
    <td width="120">
      &#8220;(hi|h)?me&#8221;
    </td>
    
    <td>
      匹配含有&#8221;hi&#8221; 或者 &#8220;h&#8221;这样0个或多个，并且后面跟着me 的 字符串；
    </td>
  </tr>
</table>

5、一个点(&#8216;.&#8217;)可以代表所有的单一字符，不包括&#8221;\n&#8221;，如果要匹配&#8221;\n&#8221;，用'[\n.]&#8217;这种模式。

<table style="border:1px solid #CCC;" width="600" border="0" cellspacing="" cellpadding="4">
  <tr>
    <td width="120">
      &#8220;t.{1,2}p&#8221;
    </td>
    
    <td width="240">
      t后面加上1-2个任意字符加上p；
    </td>
    
    <td width="240">
      tip；toop；tucp； &#8230;
    </td>
  </tr>
  
  <tr>
    <td width="120">
      &#8220;^.{3}$&#8221;
    </td>
    
    <td width="240">
      三个任意字符；
    </td>
    
    <td width="240">
      123；asf；&#8230;
    </td>
  </tr>
</table>

6、中括号'[]&#8217;：中括号括住的内容只匹配一个单一的字符 。当^用在中括号开头的时候，就表示排除括号里的字符。

<table style="border:1px solid #CCC;" width="600" border="0" cellspacing="" cellpadding="4">
  <tr>
    <td width="120">
      &#8220;[ab]&#8221;
    </td>
    
    <td>
      匹配单个的 a 或者 b ( 和 &#8220;a│b&#8221; 一样)；
    </td>
  </tr>
  
  <tr>
    <td width="120">
      &#8220;[a-d]&#8221;
    </td>
    
    <td>
      : 匹配&#8217;a&#8217; 到&#8217;d&#8217;的单个字符 (和&#8221;a│b│c│d&#8221; 还有 &#8220;[abcd]&#8221;效果一样)；
    </td>
  </tr>
  
  <tr>
    <td width="120">
      &#8220;^[a-zA-Z]&#8221;
    </td>
    
    <td>
      匹配以大小写字母开头的字符串；
    </td>
  </tr>
  
  <tr>
    <td width="120">
      &#8220;[0-9]%&#8221;
    </td>
    
    <td>
      匹配含有 形如 x％ 的字符串；
    </td>
  </tr>
  
  <tr>
    <td width="120">
      &#8220;,[a-zA-Z0-9]$&#8221;
    </td>
    
    <td>
      匹配以逗号再加一个数字或字母结尾的字符串；
    </td>
  </tr>
  
  <tr>
    <td width="120">
      &#8220;%[^a-zA-Z]%&#8221;
    </td>
    
    <td>
      匹配含有两个百分号里面有一个非字母的字符串
    </td>
  </tr>
</table>

注：一般我们都用[a-zA-Z]来指定字符为一个大小写英文

7、为了PHP能够解释，一些特殊字符必须在这些字符面前后加&#8221;，并且将一些字符转义。

不要忘记在中括号里面的字符是这条规路的例外—在中括号里面，所有的特殊字符，包括(&#8221;)，都将失去他们的特殊性质 &#8220;[*\+?{}.]&#8221;匹配含有这些字符的字符串：

还有，正如regx的手册告诉我们：&#8221;如果列表里含有&#8217;]&#8217;，最好把它作为列表里的第一个字符(可能跟在&#8217;^&#8217;后面)。如果含有&#8217;-&#8216;，最好把它放在最前面或者最后面， or 或者一个范围的第二个结束点[a-d-0-9]中间的‘-&#8216;将有效。

看了上面的例子，你对{n,m}应该理解了吧。要注意的是，n和m都不能为负整数，而且n总是小于m。这样，才能 最少匹配n次且最多匹配m次。如&#8221;p{1,5}&#8221;将匹配 &#8220;pvpppppp&#8221;中的前五个p

看一个具体的例子： 构造检查email的正则表达式

在一个完整的email地址中有三个部分：

1. 用户名 (在 &#8216;@&#8217; 左边的一切) ：要求是含有大小写字母阿拉伯数字，句号(&#8216;.&#8217;)减号(&#8216;-&#8216;)and下划线&#8217;_&#8217;)。

2.&#8217;@&#8217;

3. 服务器名(就是剩下那部分) ：要求和用户名的规则差不多，唯独不能允许下划线的存在。

现在，用户名的开始和结束都不能是句点，服务器也是这样。还有你不能有两个连续的句点他们之间至少存在一个字符，好现在我们来看一下怎么为用户名写一个匹配模式：

^[_a-zA-Z0-9-]+$

现在还不能允许句号的存在。我们把它加上：

^[\_a-zA-Z0-9-]+(.[\_a-zA-Z0-9-]+)*$

上面的意思就是说：以至少一个规范字符（除了.）开头，后面跟着0个或者多个以点开始的字符串。  
后面的服务器名字也是一样，但要去掉下划线：

^[a-zA-Z0-9-]+(.[a-zA-Z0-9-]+)*$

好。现在只需要用”@”把两部分连接：

^[\_a-zA-Z0-9-]+(.[\_a-zA-Z0-9-]+)\*@[a-zA-Z0-9-]+(.[a-zA-Z0-9-]+)\*$  
这就是完整的email认证匹配模式了，只需要调用：

preg(&#8220;^[\_a-z0-9-]+(\.[\_a-z0-9-]+)\*@[a-z0-9-]+(\.[a-z0-9-]+)\*$&#8221;,$eamil)

就可以得到是否为email了